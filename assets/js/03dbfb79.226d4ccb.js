"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[4522],{9813:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"language/basic-concepts","title":"Basic Concepts","description":"Acorn is a line-oriented language. Usually, you write one thing on one line, then continue on to the next line.","source":"@site/docs/language/basic-concepts.md","sourceDirName":"language","slug":"/language/basic-concepts","permalink":"/docs/language/basic-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/tree/main/packages/create-docusaurus/templates/shared/docs/language/basic-concepts.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"sidebar","previous":{"title":"Language Reference","permalink":"/docs/category/language-reference"},"next":{"title":"Quantifiers","permalink":"/docs/language/quantifiers"}}');var a=s(4848),r=s(8453);const i={sidebar_position:1},o="Basic Concepts",c={},l=[{value:"Theorems",id:"theorems",level:2},{value:"Expressions",id:"expressions",level:2},{value:"Statements",id:"statements",level:2},{value:"Types",id:"types",level:2},{value:"Non-features",id:"non-features",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"basic-concepts",children:"Basic Concepts"})}),"\n",(0,a.jsx)(n.p,{children:"Acorn is a line-oriented language. Usually, you write one thing on one line, then continue on to the next line."}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes, code is grouped into blocks. These are delineated with ",(0,a.jsx)(n.code,{children:"{ ... }"})," braces, and sometimes keywords to connect subsequent blocks. Inside the blocks, it's one thing per line."]}),"\n",(0,a.jsxs)(n.p,{children:["Comments start with ",(0,a.jsx)(n.code,{children:"//"})," and extend through the rest of the line."]}),"\n",(0,a.jsx)(n.p,{children:"Line breaks inside parentheses or after infix operators are ignored, which you can use to split a statement among multiple lines if you want."}),"\n",(0,a.jsx)(n.h2,{id:"theorems",children:"Theorems"}),"\n",(0,a.jsx)(n.p,{children:"A typical Acorn file is mostly a bunch of theorems. Theorems look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"theorem my_theorem(var1: Type1, var2: Type2, var3: Type3) {\n    expression\n} by {\n    statement1\n    statement2\n    statement3\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Theorems typically have two blocks. The first block is the thing we're proving. The ",(0,a.jsx)(n.code,{children:"by"})," block is the proof. If it's simple enough for the AI to prove directly, the second block is optional."]}),"\n",(0,a.jsx)(n.p,{children:"The variables defined as the arguments to the theorem can be used within both the expression of the theorem, and its proof."}),"\n",(0,a.jsx)(n.h2,{id:"expressions",children:"Expressions"}),"\n",(0,a.jsx)(n.p,{children:"An expression in Acorn is either a named value, or a way of building one value out of other values. Here are some example expressions."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"// Logic\np -> q\np or q\np and q\nnot p\np <-> q\ntrue\nfalse\n\n// Arithmetic\n1 + 1\n(1 + 2) * 3\n2 + 2 < 5\n\n// Calling functions\nfoo(bar, baz, qux)\n\n// An equality is an expression\n2 + 2 = 4\n\n// Expressions can get complicated\nn > 1 and not exists(d: Nat) { d > 1 and d != n and exists(q: Nat) { q * d = n } }\n"})}),"\n",(0,a.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,a.jsx)(n.p,{children:"Acorn is a statement-based language. When you verify Acorn code, it checks that every statement is well-formed and true."}),"\n",(0,a.jsx)(n.p,{children:"If you write an expression by itself on a line, that counts as a statement. You are expressing the proposition that this expression is always true."}),"\n",(0,a.jsx)(n.p,{children:"Let's look an example from the standard library:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"theorem lt_cancel_suc(a: Nat, b: Nat) {\n    a.suc < b.suc -> a < b\n} by {\n    a.suc <= b.suc\n    b.suc != a.suc\n    a <= b and b != a\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:'The entire theorem is a statement. It doesn\'t have a "return value". Once the verifier proves it, all the subsequent code can use it as a proof step.'}),"\n",(0,a.jsxs)(n.p,{children:["The individual lines inside the ",(0,a.jsx)(n.code,{children:"by"}),' block are also each simple statements. They are each single expressions. You can think of single-expression statements as saying, "I declare that this expression is true".']}),"\n",(0,a.jsx)(n.p,{children:"Inside the block, any premises of the theorem statement can be assumed to be true. In this case, the premise is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"a.suc < b.suc\n"})}),"\n",(0,a.jsx)(n.p,{children:"When the verifier runs, it finds a proof for each statement in the block. Each statement can use the statements before it."}),"\n",(0,a.jsx)(n.p,{children:"Finally, it finds a proof for the conclusion of the theorem itself, based on all the statements inside the block. In this case, the conclusion is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"a < b\n"})}),"\n",(0,a.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,a.jsx)(n.p,{children:"Acorn has strong, static typing. Every expression has a type."}),"\n",(0,a.jsx)(n.p,{children:"Variable names start with a lowercase letter. Type names start with an uppercase letter."}),"\n",(0,a.jsx)(n.p,{children:"Function types can be defined based on their argument type and return type:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:'// Functions that take a natural number and return another, like "successor"\nNat -> Nat\n\n// Functions that take two natural numbers and return another, like "addition"\n(Nat, Nat) -> Nat\n'})}),"\n",(0,a.jsx)(n.h2,{id:"non-features",children:"Non-features"}),"\n",(0,a.jsx)(n.p,{children:"Acorn's goal is to make it easy to do math with the help of powerful AI. Completeness can be sacrificed in favor of any other quality."}),"\n",(0,a.jsx)(n.p,{children:"Acorn is not a programming language. You can't write a webserver in it."}),"\n",(0,a.jsx)(n.p,{children:"Acorn does not support constructive logic. Classical logic, including the law of the excluded middle, is built into the kernel."}),"\n",(0,a.jsx)(n.p,{children:"Acorn assumes the axiom of choice. Skolemization is built into the kernel."}),"\n",(0,a.jsx)(n.p,{children:"Acorn doesn't really use the Curry-Howard correspondence. Proofs and types are different things. Typechecking happens first, then proving."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);