"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[4515],{3786:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"tutorial/multi-step-proofs","title":"Multi-step Proofs","description":"Often a theorem isn\'t so obvious that you just realize it\'s true in a single flash of insight. Instead, you think about it, and you start to see a sequence of things that follow from the premises. Your thought process goes:","source":"@site/docs/tutorial/multi-step-proofs.md","sourceDirName":"tutorial","slug":"/tutorial/multi-step-proofs","permalink":"/docs/tutorial/multi-step-proofs","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/tutorial/multi-step-proofs.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"sidebar","previous":{"title":"Tutorial","permalink":"/docs/category/tutorial"},"next":{"title":"Indirect Proofs","permalink":"/docs/tutorial/indirect-proofs"}}');var o=t(4848),r=t(8453);const i={sidebar_position:1},a="Multi-step Proofs",l={},h=[{value:"Proof Blocks",id:"proof-blocks",level:2},{value:"Threeven",id:"threeven",level:2},{value:"The Essence of Being Threeven",id:"the-essence-of-being-threeven",level:2},{value:"The Ways Things Can Go Wrong",id:"the-ways-things-can-go-wrong",level:2},{value:"The Basic Development Cycle",id:"the-basic-development-cycle",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"multi-step-proofs",children:"Multi-step Proofs"})}),"\n",(0,o.jsx)(n.p,{children:"Often a theorem isn't so obvious that you just realize it's true in a single flash of insight. Instead, you think about it, and you start to see a sequence of things that follow from the premises. Your thought process goes:"}),"\n",(0,o.jsxs)(n.p,{children:['"Given that ',(0,o.jsx)(n.code,{children:"my_premise"})," is true, we know that ",(0,o.jsx)(n.code,{children:"first_step"})," must be true. Then we know that ",(0,o.jsx)(n.code,{children:"second_step"})," is true... well, if we have both of those, then we also can conclude ",(0,o.jsx)(n.code,{children:"third_step"}),". And that implies ",(0,o.jsx)(n.code,{children:"interesting_conclusion"}),". So ",(0,o.jsx)(n.code,{children:"my_premise"})," implies ",(0,o.jsx)(n.code,{children:"interesting_conclusion"}),", nice, that's a cool theorem.\""]}),"\n",(0,o.jsx)(n.h2,{id:"proof-blocks",children:"Proof Blocks"}),"\n",(0,o.jsx)(n.p,{children:"The way you express this in Acorn is with a theorem statement that has a proof block:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"theorem cool_theorem {\n    my_premise -> interesting_conclusion\n} by {\n    first_step\n    second_step\n    third_step\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"When humans are communicating proofs to each other, we generally don't describe in great detail why each step works. We just break the proof down into steps, where each step is obvious. If a step isn't obvious, you ask for more detail."}),"\n",(0,o.jsxs)(n.p,{children:["Acorn works the same way. You write a proof, and Acorn tells you whether it understands all the steps or not. The keyword ",(0,o.jsx)(n.code,{children:"by"})," introduces the block, the block has one step per line, and the block itself is delineated by ",(0,o.jsx)(n.code,{children:"{ ... }"})," braces."]}),"\n",(0,o.jsx)(n.p,{children:"We should go through a nontrivial proof so that this makes sense. Let's start by defining a novel and innovative mathematical concept, and then do some proofs about it."}),"\n",(0,o.jsx)(n.h2,{id:"threeven",children:"Threeven"}),"\n",(0,o.jsx)(n.p,{children:"Open up a new Acorn file and type this in."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"from nat import Nat\nnumerals Nat\n\ndefine threeven(n: Nat) -> Bool {\n    exists(d: Nat) {\n        3 * d = n\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The example code is ",(0,o.jsx)(n.a,{href:"https://github.com/acornprover/acornprover.org/blob/master/examples/",children:"available here"})," if you just want the final version."]}),"\n",(0,o.jsx)(n.p,{children:'If a number is divisible by two, we call that "even". Naturally, if a number is divisible by three, we should call that "threeven".'}),"\n",(0,o.jsx)(n.p,{children:"This code uses some Acorn keywords that we haven't seen before."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"numerals Nat\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This tells Acorn that in the rest of this file, numerals like ",(0,o.jsx)(n.code,{children:"3"})," should be interpreted as natural numbers."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"define threeven(n: Nat) -> Bool\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This defines a new function, called ",(0,o.jsx)(n.code,{children:"threeven"}),". The function takes one argument, a natural number, and returns a boolean value, which just means it can be true or false. Note that ",(0,o.jsx)(n.code,{children:"Nat"})," and ",(0,o.jsx)(n.code,{children:"Bool"})," are capitalized, because they are types."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"exists(d: Nat) {\n    3 * d = n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"exists"})," is the existential quantifier. A number ",(0,o.jsx)(n.code,{children:"n"})," is threeven if there's some other number, ",(0,o.jsx)(n.code,{children:"d"}),", that you can multiply by 3 to get ",(0,o.jsx)(n.code,{children:"n"}),". There's also ",(0,o.jsx)(n.code,{children:"forall"}),", the universal quantifier."]}),"\n",(0,o.jsx)(n.h2,{id:"the-essence-of-being-threeven",children:"The Essence of Being Threeven"}),"\n",(0,o.jsxs)(n.p,{children:["Now that we've defined ",(0,o.jsx)(n.code,{children:"threeven"}),", we can prove theorems about it. For simple theorems, we can just state the theorem itself."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"theorem zero_is_threeven {\n    threeven(0)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Type this in, save the file, and you should see a little check mark appear. But now, try the same thing with a trickier theorem."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"theorem threeven_plus_three(n: Nat) {\n    threeven(n) -> threeven(n + 3)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Save this file, and you'll see something different - Acorn puts a yellow squiggle on the theorem."}),"\n",(0,o.jsx)(n.p,{children:"(Once the AI gets better, we'll have to update this tutorial with a harder theorem!)"}),"\n",(0,o.jsx)(n.p,{children:"Think of the yellow squiggle as a \"mathematical warning\". Acorn isn't sure whether this statement is true or not. It's like you're the professor, and the AI is a student, asking \"Wait, this is trivial to you, but I don't follow. Can you explain in more detail?\""}),"\n",(0,o.jsx)(n.p,{children:"Click the yellow squiggle, and the assistant will think harder and see if it can figure out a proof. It might find a proof, which you can accept. Or it might fail, or you might consider its proof to be ugly. Either way, you need to provide more detailed steps. For example, this should work:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"theorem threeven_plus_three(n: Nat) {\n    threeven(n) -> threeven(n + 3)\n} by {\n    let d: Nat satisfy {\n        3 * d = n\n    }\n    3 * (d + 1) = n + 3\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"There's a new type of statement here:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"let d: Nat satisfy {\n    3 * d = n\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"let d: Nat satisfy { ... }"})," is the same as ",(0,o.jsx)(n.code,{children:"exists(d: Nat) { ... }"}),", except it also makes the variable ",(0,o.jsx)(n.code,{children:"d"})," usable in the following code."]}),"\n",(0,o.jsx)(n.p,{children:"In this proof, Acorn can see how to prove each step from the steps before it. So it accepts the multi-step proof."}),"\n",(0,o.jsx)(n.h2,{id:"the-ways-things-can-go-wrong",children:"The Ways Things Can Go Wrong"}),"\n",(0,o.jsx)(n.p,{children:"The yellow squiggle is one sort of trouble you can have. You can also have a red squiggle."}),"\n",(0,o.jsx)(n.p,{children:"Maybe you've run into this already. Try writing this code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-acorn",children:"theorem {\n    blorf + blonk = flump\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This should give you a red squiggle, which you can hover to see an error message like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"unknown identifier 'blorf':\n    blorf + blonk = flump\n    ^^^^^\n"})}),"\n",(0,o.jsx)(n.p,{children:"If there's an error but you don't see where it is, hit F8 to jump to it in VS Code."}),"\n",(0,o.jsxs)(n.p,{children:["The red squiggle is a compile-time error. You get a red squiggle because you entered an expression that doesn't make sense. The syntax is wrong, or you're using a name that doesn't mean anything, or you forgot a parenthesis, or there's a type error, like adding ",(0,o.jsx)(n.code,{children:"3 + false"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"the-basic-development-cycle",children:"The Basic Development Cycle"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Write the steps in your proof."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"When you get a red squiggle, you typed something in wrong. Fix it."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"When you get a yellow squiggle, that step isn't simple enough. Add more steps."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Many proofs can be expressed in this sequential way. But sometimes, it's more convenient to structure the proof differently. Next, let's discuss indirect proofs."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);