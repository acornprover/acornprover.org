"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[2908],{7663:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"language/typeclasses","title":"Typeclasses","description":"Typeclasses let you prove something for a bunch of types at once.","source":"@site/docs/language/typeclasses.md","sourceDirName":"language","slug":"/language/typeclasses","permalink":"/docs/language/typeclasses","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/language/typeclasses.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"sidebar","previous":{"title":"Generics","permalink":"/docs/language/generics"},"next":{"title":"Experimental Stuff","permalink":"/docs/language/experimental-stuff"}}');var a=n(4848),i=n(8453);const c={sidebar_position:10},r="Typeclasses",o={},l=[{value:"The <code>typeclass</code> Statement",id:"the-typeclass-statement",level:2},{value:"Using Typeclasses",id:"using-typeclasses",level:2},{value:"The <code>instance</code> Statement",id:"the-instance-statement",level:2},{value:"Typeclass Attributes Vs Type Attributes",id:"typeclass-attributes-vs-type-attributes",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"typeclasses",children:"Typeclasses"})}),"\n",(0,a.jsx)(t.p,{children:"Typeclasses let you prove something for a bunch of types at once."}),"\n",(0,a.jsx)(t.p,{children:"Think of a typeclass as a small bundle of attributes or operations, plus the rules they must satisfy. The typeclass lets you state an abstract theorem once, in terms of these operations, and then apply them to many different types, without extra code."}),"\n",(0,a.jsxs)(t.h2,{id:"the-typeclass-statement",children:["The ",(0,a.jsx)(t.code,{children:"typeclass"})," Statement"]}),"\n",(0,a.jsx)(t.p,{children:"To define a typeclass you specify two things: the required attributes, and the rules they must follow."}),"\n",(0,a.jsxs)(t.p,{children:["In Acorn code, these happen inside a ",(0,a.jsx)(t.code,{children:"typeclass"})," statement. For example, this is how you define a metric space:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"from real import Real\nnumerals Real\n\ntypeclass M: MetricSpace {\n    // Every metric space must have a distance function\n    distance: (M, M) -> Real\n\n    // Rule: the distance from a point to itself is zero\n    self_distance_is_zero(x: M) {\n        x.distance(x) = 0\n    }\n\n    // Rule: distance zero means the points are equal\n    dist_zero_imp_eq(x: M, y: M) {\n        x.distance(y) = 0 implies x = y\n    }\n\n    // Rule: distance must be symmetric\n    symmetric(x: M, y: M) {\n        x.distance(y) = y.distance(x)\n    }\n\n    // Rule: distance must satisfy the triangle inequality\n    triangle(x: M, y: M, z: M) {\n        x.distance(z) <= x.distance(y) + y.distance(z)\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this statement, ",(0,a.jsx)(t.code,{children:"M"})," refers to the type that belongs to the ",(0,a.jsx)(t.code,{children:"MetricSpace"}),' typeclass. We call this sort of type an "instance" of the typeclass.']}),"\n",(0,a.jsx)(t.p,{children:"Attributes are defined by providing a type. For example, in this line:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"distance: (M, M) -> Real\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The type of ",(0,a.jsx)(t.code,{children:"distance"})," is a function from two ",(0,a.jsx)(t.code,{children:"M"}),"-type variables, to the real numbers. That's a function from two elements of our metric space, to the reals."]}),"\n",(0,a.jsx)(t.p,{children:"The rules that an instance must obey are defined like theorems, with a set of arguments, along with a condition."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"self_distance_is_zero(x: M) {\n    x.distance(x) = 0\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Here, ",(0,a.jsx)(t.code,{children:"x"})," is the arguments to the rule, and ",(0,a.jsx)(t.code,{children:"x.distance(x) = 0"})," is the condition itself. This rule says that the distance between a point and itself is always zero."]}),"\n",(0,a.jsx)(t.h2,{id:"using-typeclasses",children:"Using Typeclasses"}),"\n",(0,a.jsx)(t.p,{children:"In any statement that can take generic type parameters, you can also provide typeclasses. In particular, this lets you prove theorems about a typeclass. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"theorem distance_non_negative<M: MetricSpace>(x: M, y: M) {\n    not x.distance(y).is_negative\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"(By some definitions of metric space, this would be a condition on the metric space itself. With our definition, we can prove it from the other conditions, so it can be a theorem.)"}),"\n",(0,a.jsxs)(t.p,{children:["In this theorem statement, the ",(0,a.jsx)(t.code,{children:"<M: MetricSpace>"})," expresses that we are proving this theorem generically, where ",(0,a.jsx)(t.code,{children:"M"})," can be any metric space. If we had just written ",(0,a.jsx)(t.code,{children:"<M>"}),", we would be trying to prove it for every type. That wouldn't compile, though; we can only call ",(0,a.jsx)(t.code,{children:"x.distance"})," because ",(0,a.jsx)(t.code,{children:"x"})," is a ",(0,a.jsx)(t.code,{children:"MetricSpace"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"When we prove theorems about typeclasses, we can use the conditions on the typeclass. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"theorem distance_non_negative<M: MetricSpace>(x: M, y: M) {\n    not x.distance(y).is_negative\n} by {\n    x.distance(x) <= x.distance(y) + y.distance(x)\n    0 <= x.distance(y) + x.distance(y)\n    0 <= x.distance(y)\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"The first line is true by the triangle inequality. The second is true by symmetry and the self-distance rule. As usual, you don't have to explicitly reference these theorems in Acorn because the prover will find those for you."}),"\n",(0,a.jsxs)(t.h2,{id:"the-instance-statement",children:["The ",(0,a.jsx)(t.code,{children:"instance"})," Statement"]}),"\n",(0,a.jsxs)(t.p,{children:['A type that satisfies a typeclass is called an "instance". To declare that a type is an instance of a typeclass, we use the ',(0,a.jsx)(t.code,{children:"instance"})," statement. It looks like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"inductive Color {\n    red\n    green\n    blue\n}\n\ndefine discrete(x: Color, y: Color) -> Real {\n    if x = y {\n        0\n    } else {\n        1\n    }\n}\n\ninstance Color: MetricSpace {\n    let distance: (Color, Color) -> Real = discrete\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"A typeclass usually relies on some attributes of the instance class. In this case, a metric space requires a distance function. When we're declaring an instance class, we have to specify the typeclasss attributes. In this case, the line:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"let distance: (Color, Color) -> Real = discrete\n"})}),"\n",(0,a.jsxs)(t.p,{children:["is specifying that when we are considering the ",(0,a.jsx)(t.code,{children:"Color"})," type as an instance of the ",(0,a.jsx)(t.code,{children:"MetricSpace"})," typeclass, we should use the ",(0,a.jsx)(t.code,{children:"discrete"})," function for its ",(0,a.jsx)(t.code,{children:"distance"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"You can refer to these attributes by either the class or the typeclass name. So these expressions are now equivalent:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"MetricSpace.distance<Color>(x, y)\ndiscrete(x, y)\n"})}),"\n",(0,a.jsx)(t.p,{children:"When you write an instance statement, you also have to prove that this definition adheres to all the conditions on the typeclass. You can prove it as one big block, but it's more clear to write it as separate theorems. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"theorem discrete_self_distance_is_zero(x: Color) {\n    discrete(x, x) = 0\n}\n\ntheorem discrete_dist_zero_imp_eq(x: Color, y: Color) {\n    discrete(x, y) = 0 implies x = y\n}\n\ntheorem discrete_symmetric(x: Color, y: Color) {\n    discrete(x, y) = discrete(y, x)\n}\n\ntheorem discrete_triangle(x: Color, y: Color, z: Color) {\n    discrete(x, z) <= discrete(x, y) + discrete(y, z)\n}\n\ninstance Color: MetricSpace {\n    let distance: (Color, Color) -> Real = discrete\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This way, any condition that is unclear to Acorn will get yellow-squiggled, and you can add extra detail to the proof as needed."}),"\n",(0,a.jsx)(t.h2,{id:"typeclass-attributes-vs-type-attributes",children:"Typeclass Attributes Vs Type Attributes"}),"\n",(0,a.jsxs)(t.p,{children:["Typeclass attributes and type attributes do not have exactly the same syntax. For example, let's say we defined ",(0,a.jsx)(t.code,{children:"discrete"})," as an attribute on ",(0,a.jsx)(t.code,{children:"Color"})," rather than a top-level function."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"class Color {\n    define discrete(self, other: Color) -> Real {\n        if x = y {\n            0\n        } else {\n            1\n        }\n    }\n}\n\ninstance Color: MetricSpace {\n    let distance: (Color, Color) -> Real = Color.discrete\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Here, ",(0,a.jsx)(t.code,{children:"discrete"})," is an attribute of the ",(0,a.jsx)(t.code,{children:"Color"})," class. But ",(0,a.jsx)(t.code,{children:"distance"})," is an attribute of the ",(0,a.jsx)(t.code,{children:"MetricSpace"})," typeclass. You can use either one with explicit dot syntax:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"// If x and y are Colors, these all work\n\n// Explicitly typed, typeclass attribute\nMetricSpace.distance<Color>(x, y)\n\n// Implicitly typed, typeclass attribute\nMetricSpace.distance(x, y)\n\n// Explicitly typed, class attribute\nColor.discrete(x, y)\n\n// Implicitly typed, type attribute\nx.discrete(y)\n"})}),"\n",(0,a.jsx)(t.p,{children:"It does not work to mix the two:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"// Does not work\nx.distance(y)\n"})}),"\n",(0,a.jsx)(t.p,{children:'The rationale is that a type may belong to two different typeclasses, both of which use the same name for an attribute. We avoid this "diamond inheritance" problem by always making it clear from the context which attribute we are using.'}),"\n",(0,a.jsx)(t.p,{children:"With a generic theorem, you can use the implicit dot syntax to refer to typeclass attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"// x.distance(y) is okay when x is an M: MetricSpace.\n// It isn't okay when x is a Color.\ntheorem distance_non_negative<M: MetricSpace>(x: M, y: M) {\n    not x.distance(y).is_negative\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is because the meaning of ",(0,a.jsx)(t.code,{children:"x.distance(y)"})," is clear from the context."]}),"\n",(0,a.jsxs)(t.p,{children:["The same holds for infix operators. For example, ",(0,a.jsx)(t.code,{children:"x * y"})," is just syntactic sugar for ",(0,a.jsx)(t.code,{children:"x.mul(y)"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Currently, a class can only be an instance of a typeclass in one way. It's possible that we add additional syntax to handle this case in the future."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);