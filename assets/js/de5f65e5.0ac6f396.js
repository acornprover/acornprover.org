"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[9778],{1581:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"language/experimental-stuff","title":"Experimental Stuff","description":"Overall, the Acorn language is in beta. Features are likely to change as we get feedback from people using the software.","source":"@site/docs/language/experimental-stuff.md","sourceDirName":"language","slug":"/language/experimental-stuff","permalink":"/docs/language/experimental-stuff","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/language/experimental-stuff.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"sidebar","previous":{"title":"Classes","permalink":"/docs/language/classes"},"next":{"title":"Library Reference","permalink":"/docs/category/library-reference"}}');var s=n(4848),r=n(8453);const o={sidebar_position:10},i="Experimental Stuff",l={},c=[{value:"Polymorphism",id:"polymorphism",level:2},{value:"Reading Numerals",id:"reading-numerals",level:2},{value:"Solve Statements",id:"solve-statements",level:2},{value:"Axiom Statements",id:"axiom-statements",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"experimental-stuff",children:"Experimental Stuff"})}),"\n",(0,s.jsx)(t.p,{children:"Overall, the Acorn language is in beta. Features are likely to change as we get feedback from people using the software."}),"\n",(0,s.jsx)(t.p,{children:"We can't promise that your code will not break. But, we can promise that if you get a pull request merged into the standard library, we'll keep it updated as the language changes. Consider that an incentive to share your code."}),"\n",(0,s.jsx)(t.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,s.jsx)(t.p,{children:"You can make theorems and functions polymorphic. For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-acorn",children:"define repeat<T>(n: Nat, f: T -> T, a: T) -> T {\n    match n {\n        Nat.zero {\n            a\n        }\n        Nat.suc(pred) {\n            repeat(pred, f, f(a))\n        }\n    }\n}\n\ntheorem goal<T>(a: T, b: T, c: T) {\n    a = b and b = c -> a = c\n} by {\n    if (a = b and b = c) {\n        a = c\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This isn't quite enough to be useful. We at least need types to be polymorphic, to express concepts like ",(0,s.jsx)(t.code,{children:"List<T>"}),". And it would nice to have more powerful dependent types, to handle stuff like schemes and sheaves. So, we might want to change how polymorphism currently works, in order to get there."]}),"\n",(0,s.jsx)(t.h2,{id:"reading-numerals",children:"Reading Numerals"}),"\n",(0,s.jsxs)(t.p,{children:["There is a special ",(0,s.jsx)(t.code,{children:"read"})," function. If your class has member variables for the digits ",(0,s.jsx)(t.code,{children:"0"})," through ",(0,s.jsx)(t.code,{children:"9"}),", as well as a ",(0,s.jsx)(t.code,{children:"read"})," function that combines an existing number with a new digit, it can be used in a ",(0,s.jsx)(t.code,{children:"numerals"})," statement to process number strings."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-acorn",children:"// Not exactly how it works in the standard library, but close\nclass Nat {\n    let 1: Nat = Nat.0.suc\n    let 2: Nat = Nat.1.suc\n    let 3: Nat = Nat.2.suc\n    let 4: Nat = Nat.3.suc\n    let 5: Nat = Nat.4.suc\n    let 6: Nat = Nat.5.suc\n    let 7: Nat = Nat.6.suc\n    let 8: Nat = Nat.7.suc\n    let 9: Nat = Nat.8.suc\n\n    define read(self, other: Nat) -> Nat {\n        dectuple(self) + other\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:['This is kind of weird. It would probably make more sense to process a list of characters into a numerical object directly. But, currently we don\'t have a "list" or a "character" type in the standard library. So, we probably want to change how the ',(0,s.jsx)(t.code,{children:"read"})," function works."]}),"\n",(0,s.jsx)(t.h2,{id:"solve-statements",children:"Solve Statements"}),"\n",(0,s.jsxs)(t.p,{children:['Traditionally, theorem provers are focused on proving theorems. "Solving an expression" is a very common operation in mathematics that doesn\'t quite fit into this paradigm. You can express this in Acorn with a ',(0,s.jsx)(t.code,{children:"solve"})," statement:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-acorn",children:"solve 2 + 1 by {\n    2 + 1 = 3\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:'The verifier checks that every statement in the block is correct, and it checks that the final statement is an equality using the initial expression. It doesn\'t check that it is in "simplest form", because that is not necessarily a rigorous concept.'}),"\n",(0,s.jsx)(t.p,{children:"Right now, this isn't all that useful, because the AI can't solve these problems. It can only verify solutions. So for now, these statements are only really useful for expressing training data."}),"\n",(0,s.jsx)(t.h2,{id:"axiom-statements",children:"Axiom Statements"}),"\n",(0,s.jsxs)(t.p,{children:["You can use the ",(0,s.jsx)(t.code,{children:"axiom"})," keyword to declare a theorem is true without proving it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-acorn",children:"axiom nat_plus_three_isnt_two(n: Nat) {\n    n + 3 != 2\n}\n\n// The prover accepts this\naxiom two_plus_two_is_five {\n    2 + 2 = 5\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is very handy for unit testing, but maybe we don't want to expose it for actual use."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(6540);const s={},r=a.createContext(s);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);