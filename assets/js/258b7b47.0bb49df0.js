"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[6218],{591:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"library/Nat","title":"Nat","description":"Natural numbers, the soul of arithmetic.","source":"@site/docs/library/Nat.md","sourceDirName":"library","slug":"/library/Nat","permalink":"/docs/library/Nat","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/library/Nat.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Multiset","permalink":"/docs/library/Multiset"},"next":{"title":"Option","permalink":"/docs/library/Option"}}');var a=r(4848),l=r(8453);const s={},d="Nat",i={},c=[{value:"add",id:"add",level:2},{value:"exp",id:"exp",level:2},{value:"gt",id:"gt",level:2},{value:"gte",id:"gte",level:2},{value:"lt",id:"lt",level:2},{value:"lte",id:"lte",level:2},{value:"mul",id:"mul",level:2},{value:"read",id:"read",level:2},{value:"sub",id:"sub",level:2},{value:"suc",id:"suc",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"nat",children:"Nat"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"inductive Nat {\n    0\n    suc(Nat)\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Natural numbers, the soul of arithmetic.\nWe build natural numbers from Acorn's inherent properties of inductive types."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/acornprover/acornlib/blob/master/src/nat/default.ac",children:"GitHub"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"add",children:"add"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define add(self, other: Nat) -> Nat {\n    match other {\n        Nat.0 {\n            self\n        }\n        Nat.suc(pred) {\n            self.add(pred).suc\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Addition is defined recursively."}),"\n",(0,a.jsx)(n.h2,{id:"exp",children:"exp"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define exp(self, b: Nat) -> Nat {\n    match b {\n        Nat.0 {\n            1\n        }\n        Nat.suc(pred) {\n            self * self.exp(pred)\n        }\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note that 0^0 = 1.\nTODO: ideally this would use an inherited ",(0,a.jsx)(n.code,{children:"pow"})," from ",(0,a.jsx)(n.code,{children:"Monoid"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"gt",children:"gt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define gt(self, b: Nat) -> Bool {\n    b < self\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["TODO: currently we define this separately, but we could inherit it from ",(0,a.jsx)(n.code,{children:"PartialOrder"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"gte",children:"gte"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define gte(self, b: Nat) -> Bool {\n    b <= self\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["TODO: currently we define this separately, but we could inherit it from ",(0,a.jsx)(n.code,{children:"PartialOrder"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"lt",children:"lt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define lt(self, b: Nat) -> Bool {\n    self <= b and self != b\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["TODO: currently we define this separately, but we could inherit it from ",(0,a.jsx)(n.code,{children:"PartialOrder"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"lte",children:"lte"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define lte(self, b: Nat) -> Bool {\n    exists(c: Nat) {\n        self + c = b\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"a <= b"})," if there's a naturla number that can be added to ",(0,a.jsx)(n.code,{children:"a"})," to get ",(0,a.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"mul",children:"mul"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define mul(self, b: Nat) -> Nat {\n    match b {\n        Nat.0 {\n            0\n        }\n        Nat.suc(pred) {\n            self.mul(pred) + self\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Multiplication is defined recursively."}),"\n",(0,a.jsx)(n.h2,{id:"read",children:"read"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define read(self, other: Nat) -> Nat {\n    10 * self + other\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"The number formed by appending a digit to this one in base 10."}),"\n",(0,a.jsx)(n.h2,{id:"sub",children:"sub"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"define sub(self, b: Nat) -> Nat {\n    bounded_sub(self, b)\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:['Subtraction on natural numbers is defined oddly; it "caps out" at zero.\nIf ',(0,a.jsx)(n.code,{children:"self < b"}),", then ",(0,a.jsx)(n.code,{children:"self - b = 0"}),'.\nIt would be better to define this as "not valid" on some inputs, but\nthe language doesn\'t make that convenient yet.']}),"\n",(0,a.jsx)(n.h2,{id:"suc",children:"suc"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-acorn",children:"Nat.suc: Nat -> Nat\n"})}),"\n",(0,a.jsx)(n.p,{children:"The successor of a natural number is also a natural number."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var t=r(6540);const a={},l=t.createContext(a);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);