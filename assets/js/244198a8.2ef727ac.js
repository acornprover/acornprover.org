"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[868],{6922:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"language/inductive-types","title":"Inductive Types","description":"An inductive type can refer to itself in its definition. It describes ways to build objects of this type from other objects of the type.","source":"@site/docs/language/inductive-types.md","sourceDirName":"language","slug":"/language/inductive-types","permalink":"/docs/language/inductive-types","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/language/inductive-types.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"sidebar","previous":{"title":"Structure Types","permalink":"/docs/language/structure-types"},"next":{"title":"Classes","permalink":"/docs/language/classes"}}');var i=t(4848),s=t(8453);const o={sidebar_position:8},a="Inductive Types",c={},l=[{value:"Defining your own",id:"defining-your-own",level:2},{value:"Match in definitions",id:"match-in-definitions",level:2},{value:"Recursion",id:"recursion",level:2},{value:"Induction",id:"induction",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"inductive-types",children:"Inductive Types"})}),"\n",(0,i.jsx)(n.p,{children:"An inductive type can refer to itself in its definition. It describes ways to build objects of this type from other objects of the type."}),"\n",(0,i.jsxs)(n.p,{children:["Inductive types are defined with the ",(0,i.jsx)(n.code,{children:"inductive"})," keyword. For example, the natural numbers are defined this way:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"inductive Nat {\n    0\n    suc(Nat)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This definition tells us there are two ways to build a natural number. The first way:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"Nat.0\n"})}),"\n",(0,i.jsx)(n.p,{children:"This one is the base constructor, the number zero. Every inductive type needs a base case."}),"\n",(0,i.jsx)(n.p,{children:"The second way:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"Nat.suc(n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can take the successor of any natural number to get another natural number. Here, ",(0,i.jsx)(n.code,{children:"Nat.suc(n)"})," can also be written as ",(0,i.jsx)(n.code,{children:"n.suc"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"When you define an inductive type, the principle of induction for that type gets defined automatically."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"// This theorem happens automatically; you don't need to define it.\ntheorem Nat.induction(f: Nat -> Bool, n: Nat) {\n    f(Nat.0)\n    and forall(k: Nat) {\n        f(k) implies f(Nat.suc(k))\n    }\n    implies f(n)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Constructors must be alphanumeric, plus underscores. They can either start with a lowercase letter like 'suc' or 'foo_bar_baz', or they can be all numeric digits like '0' or '10'."}),"\n",(0,i.jsx)(n.h2,{id:"defining-your-own",children:"Defining your own"}),"\n",(0,i.jsx)(n.p,{children:"Naturals are in the standard library, but you can define your own inductive types."}),"\n",(0,i.jsxs)(n.p,{children:["For example, let's define a type that represents an unordered binary tree of natural numbers. Put this in ",(0,i.jsx)(n.code,{children:"tree.ac"})," if you want to follow along:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"from nat import Nat\nnumerals Nat\n\n// Unordered binary tree\ninductive Tree {\n  leaf(Nat)\n  node(Tree, Tree)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"Tree.leaf"})," is the base constructor."]}),"\n",(0,i.jsx)(n.h2,{id:"match-in-definitions",children:"Match in definitions"}),"\n",(0,i.jsx)(n.p,{children:"You can define a function on an inductive type by defining it for each of the constructors. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"// Is this tree a three leaf?\ndefine is_three_leaf(t: Tree) -> Bool {\n  match t {\n    leaf(n) {\n      n == 3\n    }\n    node(left, right) {\n      false\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.code,{children:"match"})," as a statement. If you prove a proposition for each of the branches, that proves the proposition outside the ",(0,i.jsx)(n.code,{children:"match"})," statement."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:'// This has the effect of proving "goal".\nmatch value {\n  foo(a) {\n    foo_step_one\n    foo_step_two\n    goal\n  }\n  bar {\n    bar_step_one\n    bar_step_two\n    goal\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"recursion",children:"Recursion"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"match"}),' expressions are often useful as a building block for recursion. Inside the definition of a function, you can call the function itself on "parts" of the object being matched. For example, if we want to reverse left and right, all the way down a tree:']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"define reverse(t: Tree) -> Tree {\n  match t {\n    Tree.leaf(k) {\n      Tree.leaf(k)\n    }\n    Tree.node(left, right) {\n      Tree.node(reverse(right), reverse(left))\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'The restriction to "parts" is checked at compile time and ensures that the recursive function is well-defined.'}),"\n",(0,i.jsx)(n.h2,{id:"induction",children:"Induction"}),"\n",(0,i.jsx)(n.p,{children:"When we defined the Tree type, it created an implicit principle of induction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"// This theorem happens automatically; you don't need to define it.\ntheorem Tree.induction(f: Tree -> Bool, t: Tree) {\n  forall(n: Nat) {\n    f(Tree.leaf(n))\n  } and forall(left: Tree, right: Tree) {\n    f(left) and f(right) implies f(Tree.node(left, right))\n  } implies f(t)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The general principle of induction is that if you prove a theorem for all the constructors, it's proven for the whole type."}),"\n",(0,i.jsx)(n.p,{children:"Here's an example of generalized induction operating over our tree type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-acorn",children:"// Reversing a tree twice gives the original tree\ntheorem reverse_reverse(t: Tree) {\n  reverse(reverse(t)) = t\n} by {\n    // Base case\n    forall(k: Nat) {\n        reverse_reverse(Tree.leaf(k))\n    }\n\n    // Inductive case\n    forall(a: Tree, b: Tree) {\n        if reverse_reverse(a) and reverse_reverse(b) {\n            reverse(reverse(Tree.node(a, b))) = Tree.node(a, b)\n            reverse_reverse(Tree.node(a, b))\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When we're proving a theorem by induction, it's often helpful to refer to the theorem itself within the proof. Inside its own proof, a theorem is a function returning a Bool value. It can't be simplified to merely ",(0,i.jsx)(n.code,{children:"true"})," because it hasn't been proven yet."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);