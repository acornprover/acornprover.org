"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[6756],{9789:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"language/classes","title":"Classes","description":"Once you\'ve defined an inductive type or a structure type, you can augment it with additional class methods.","source":"@site/docs/language/classes.md","sourceDirName":"language","slug":"/language/classes","permalink":"/docs/language/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/tree/main/packages/create-docusaurus/templates/shared/docs/language/classes.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"sidebar","previous":{"title":"Inductive Types","permalink":"/docs/language/inductive-types"},"next":{"title":"Experimental Stuff","permalink":"/docs/language/experimental-stuff"}}');var s=t(4848),i=t(8453);const r={sidebar_position:9},o="Classes",c={},l=[{value:"The class Statement",id:"the-class-statement",level:2},{value:"Infix Operators",id:"infix-operators",level:2},{value:"Reading Numerals",id:"reading-numerals",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"classes",children:"Classes"})}),"\n",(0,s.jsx)(n.p,{children:"Once you've defined an inductive type or a structure type, you can augment it with additional class methods."}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's start with this ",(0,s.jsx)(n.code,{children:"LatticePoint"})," structure type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"from int import Int\nnumerals Int\n\nstructure LatticePoint {\n    x: Int\n    y: Int\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-class-statement",children:"The class Statement"}),"\n",(0,s.jsxs)(n.p,{children:["To add extra methods to the ",(0,s.jsx)(n.code,{children:"LatticePoint"})," type, you can define both methods and variables inside a block with the ",(0,s.jsx)(n.code,{children:"class"})," keyword."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"class LatticePoint {\n    // Now accessible as LatticePoint.origin\n    let origin = LatticePoint.new(0, 0)\n\n    // Now accessible as LatticePoint.swap\n    define swap(self) -> LatticePoint {\n        LatticePoint.new(self.y, self.x)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The first argument to a function must be named ",(0,s.jsx)(n.code,{children:"self"}),", and has the type of the class itself."]}),"\n",(0,s.jsxs)(n.p,{children:["Constants and functions defined inside a ",(0,s.jsx)(n.code,{children:"class"})," block are now methods accessible as ",(0,s.jsx)(n.code,{children:"TypeName.method_name"}),". For example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"theorem swap_is_involutive(p: LatticePoint) {\n    p.swap.swap = p\n} by {\n    p.swap.x = p.y\n    p.swap.y = p.x\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The names for constants and functions inside a class block are the same as outside, except that constants in a\nclass can also have numeric names. Thus ",(0,s.jsx)(n.code,{children:"Nat.0"})," is the name for zero, the natural number, and ",(0,s.jsx)(n.code,{children:"Int.0"})," is the name for zero, the integer."]}),"\n",(0,s.jsxs)(n.p,{children:["It's okay to have multiple ",(0,s.jsx)(n.code,{children:"class"})," blocks for a single class. You often want to define some methods, prove some things about them, then define more methods."]}),"\n",(0,s.jsx)(n.h2,{id:"infix-operators",children:"Infix Operators"}),"\n",(0,s.jsxs)(n.p,{children:["Every infix operator has a alphabetical name. If you define a method of this name, the infix operator will work as well. For example, the ",(0,s.jsx)(n.code,{children:"+"})," operator corresponds to the name ",(0,s.jsx)(n.code,{children:"add"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"class LatticePoint {\n    define add(self, other: LatticePoint) {\n        LatticePoint.new(self.x + other.x, self.y + other.y)\n    }\n}\n\ntheorem add_origin(p: LatticePoint) {\n    p + LatticePoint.origin = p\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The names of the supported infix operators are:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"// Greater than\na.gt(b) = a > b\n\n// Less than\na.lt(b) = a < b\n\n// Greater than or equal to\na.gte(b) = a >= b\n\n// Less than or equal to\na.lte(b) = a <= b\n\n// Addition\na.add(b) = a + b\n\n// Subtraction\na.sub(b) = a - b\n\n// Multiplication\na.mul(b) = a * b\n\n// Division\na.div(b) = a / b\n\n// Mod\na.mod(b) = a % b\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reading-numerals",children:"Reading Numerals"}),"\n",(0,s.jsxs)(n.p,{children:["There is also a special ",(0,s.jsx)(n.code,{children:"read"})," function. If your class has member variables for the digits ",(0,s.jsx)(n.code,{children:"0"})," through ",(0,s.jsx)(n.code,{children:"9"}),", as well as a ",(0,s.jsx)(n.code,{children:"read"})," function that combines an existing number with a new digit, it can be used in a ",(0,s.jsx)(n.code,{children:"numerals"})," statement to process number strings."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"// Not exactly how it works in the standard library, but close\nclass Nat {\n    let 1: Nat = Nat.0.suc\n    let 2: Nat = Nat.1.suc\n    let 3: Nat = Nat.2.suc\n    let 4: Nat = Nat.3.suc\n    let 5: Nat = Nat.4.suc\n    let 6: Nat = Nat.5.suc\n    let 7: Nat = Nat.6.suc\n    let 8: Nat = Nat.7.suc\n    let 9: Nat = Nat.8.suc\n\n    define read(self, other: Nat) -> Nat {\n        dectuple(self) + other\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is kind of weird, but currently we don't have a \"string\" type in the language, so some amount of weirdness is inescapable. Don't get your heart set on this functionality working this way forever."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);