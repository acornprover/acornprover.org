"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[7725],{9398:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"language/imports","title":"Imports","description":"Imports in Acorn work similarly to imports in Python.","source":"@site/docs/language/imports.md","sourceDirName":"language","slug":"/language/imports","permalink":"/docs/language/imports","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/language/imports.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"sidebar","previous":{"title":"Functions","permalink":"/docs/language/functions"},"next":{"title":"Structure Types","permalink":"/docs/language/structure-types"}}');var s=t(4848),o=t(8453);const i={sidebar_position:6},a="Imports",l={},d=[{value:"Importing Values",id:"importing-values",level:2},{value:"What You Can Import",id:"what-you-can-import",level:2},{value:"Caveat Mathematicus",id:"caveat-mathematicus",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"imports",children:"Imports"})}),"\n",(0,s.jsx)(n.p,{children:"Imports in Acorn work similarly to imports in Python."}),"\n",(0,s.jsx)(n.p,{children:"Module names are like variable names: they must start with a lowercase letter, and they may use alphanumeric characters, plus underscore."}),"\n",(0,s.jsxs)(n.p,{children:["Every file corresponds to one module. The name for a file is the module name, plus an ",(0,s.jsx)(n.code,{children:".ac"})," suffix."]}),"\n",(0,s.jsx)(n.p,{children:"The syntax for imports is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"from module import name1, name2\n"})}),"\n",(0,s.jsx)(n.h1,{id:"importing-types",children:"Importing Types"}),"\n",(0,s.jsxs)(n.p,{children:["Often, the only thing you need to import is types. The convention is for type names to be ",(0,s.jsx)(n.code,{children:"CamelCase"}),", with module names as the matching ",(0,s.jsx)(n.code,{children:"snake_case"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"from nat import Nat\nnumerals Nat\n\ntheorem even_nearby(n: Nat) {\n  2.divides(n) or 2.divides(n + 1)\n} by {\n  let (q: Nat, r: Nat) satisfy {\n    r < 2 and n = q * 2 + r\n  }\n  if r = 0 {\n    2.divides(n)\n  } else {\n    r = 1\n    n = q * 2 + 1\n    n + 1 = (q + 1) * 2\n    2.divides(n + 1)\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"numerals"})," statement tells Acorn what type should be used to interpret numerals in this file, like ",(0,s.jsx)(n.code,{children:"0"}),", ",(0,s.jsx)(n.code,{children:"1"}),", and ",(0,s.jsx)(n.code,{children:"2"}),". It's simplest do this at the top of the file, first all your ",(0,s.jsx)(n.code,{children:"import"})," statements, then a ",(0,s.jsx)(n.code,{children:"numerals"})," statement if you want one."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"divides"})," method is defined on the ",(0,s.jsx)(n.code,{children:"Nat"})," type. Attributes and theorems of a type come along when the type is imported."]}),"\n",(0,s.jsx)(n.h2,{id:"importing-values",children:"Importing Values"}),"\n",(0,s.jsxs)(n.p,{children:["In some cases, functions or other values are defined at the top level, unattached to a type. You can import these as well. For example, if ",(0,s.jsx)(n.code,{children:"divides"})," had been defined as a top-level function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-acorn",children:"from nat import Nat, divides\nnumerals Nat\n\ntheorem even_nearby(n: Nat) {\n  divides(2, n) or divides(2, n + 1)\n} by {\n  let (q: Nat, r: Nat) satisfy {\n    r < 2 and n = q * 2 + r\n  }\n  if r = 0 {\n    divides(2, n)\n  } else {\n    r = 1\n    n = q * 2 + 1\n    n + 1 = (q + 1) * 2\n    divides(2, n + 1)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is less convenient than using type attributes, because you have to import the name. Plus, for attributes, you can use IDE autocomplete to remember their name. So it's encouraged to use attributes over top-level functions wherever possible, to keep the code organized."}),"\n",(0,s.jsx)(n.h2,{id:"what-you-can-import",children:"What You Can Import"}),"\n",(0,s.jsx)(n.p,{children:"You can import any types, variables, and functions defined at the top level."}),"\n",(0,s.jsx)(n.p,{children:"You can import individual theorems to cite them, but you generally shouldn't need to. Acorn's prover will index all theorems in the imported modules and use them for proving."}),"\n",(0,s.jsx)(n.h2,{id:"caveat-mathematicus",children:"Caveat Mathematicus"}),"\n",(0,s.jsx)(n.p,{children:"Currently, you can only import from the standard library. You can't import your own modules. We'll need to improve this, in the fullness of time."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);