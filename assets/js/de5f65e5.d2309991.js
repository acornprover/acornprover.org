"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[9778],{1581:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"language/experimental-stuff","title":"Experimental Stuff","description":"Overall, the Acorn language is in beta. Features are likely to change as we get feedback from people using the software.","source":"@site/docs/language/experimental-stuff.md","sourceDirName":"language","slug":"/language/experimental-stuff","permalink":"/docs/language/experimental-stuff","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/tree/main/packages/create-docusaurus/templates/shared/docs/language/experimental-stuff.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"sidebar","previous":{"title":"Classes","permalink":"/docs/language/classes"},"next":{"title":"Library Reference","permalink":"/docs/category/library-reference"}}');var a=n(4848),r=n(8453);const o={sidebar_position:10},i="Experimental Stuff",l={},c=[{value:"Polymorphism",id:"polymorphism",level:2},{value:"Solve Statements",id:"solve-statements",level:2},{value:"Axiom Statements",id:"axiom-statements",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"experimental-stuff",children:"Experimental Stuff"})}),"\n",(0,a.jsx)(t.p,{children:"Overall, the Acorn language is in beta. Features are likely to change as we get feedback from people using the software."}),"\n",(0,a.jsx)(t.p,{children:"We can't promise that your code will not break. But, we can promise that if you get a pull request merged into the standard library, we'll keep it updated as the language changes. Consider that an incentive to share your code."}),"\n",(0,a.jsx)(t.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,a.jsx)(t.p,{children:"You can make theorems and functions polymorphic. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"define repeat<T>(n: Nat, f: T -> T, a: T) -> T {\n    match n {\n        Nat.zero {\n            a\n        }\n        Nat.suc(pred) {\n            repeat(pred, f, f(a))\n        }\n    }\n}\n\ntheorem goal<T>(a: T, b: T, c: T) {\n    a = b and b = c -> a = c\n} by {\n    if (a = b and b = c) {\n        a = c\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This isn't quite enough to be useful. We at least need types to be polymorphic, to express concepts like ",(0,a.jsx)(t.code,{children:"List<T>"}),". And it would nice to have more powerful dependent types, to handle stuff like schemes and sheaves. So, we might want to change how polymorphism currently works, in order to get there."]}),"\n",(0,a.jsx)(t.h2,{id:"solve-statements",children:"Solve Statements"}),"\n",(0,a.jsxs)(t.p,{children:['Traditionally, theorem provers are focused on proving theorems. "Solving an expression" is a very common operation in mathematics that doesn\'t quite fit into this paradigm. You can express this in Acorn with a ',(0,a.jsx)(t.code,{children:"solve"})," statement:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"solve 2 + 1 by {\n    2 + 1 = 3\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:'The verifier checks that every statement in the block is correct, and it checks that the final statement is an equality using the initial expression. It doesn\'t check that it is in "simplest form", because that is not necessarily a rigorous concept.'}),"\n",(0,a.jsx)(t.p,{children:"Right now, this isn't all that useful, because the AI can't solve these problems. It can only verify solutions. So for now, these statements are only really useful for expressing training data."}),"\n",(0,a.jsx)(t.h2,{id:"axiom-statements",children:"Axiom Statements"}),"\n",(0,a.jsxs)(t.p,{children:["You can use the ",(0,a.jsx)(t.code,{children:"axiom"})," keyword to declare a theorem is true without proving it."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-acorn",children:"axiom nat_plus_three_isnt_two(n: Nat) {\n    n + 3 != 2\n}\n\n// The prover accepts this\naxiom two_plus_two_is_five {\n    2 + 2 = 5\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This was useful during development, but it isn't clear if it's useful to keep this feature around."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(6540);const a={},r=s.createContext(a);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);