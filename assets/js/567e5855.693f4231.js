"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[2983],{3997:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"language/attributes","title":"Attributes","description":"Once you\'ve defined an inductive type or a structure type, you can augment it with additional attributes.","source":"@site/docs/language/attributes.md","sourceDirName":"language","slug":"/language/attributes","permalink":"/docs/language/attributes","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/language/attributes.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"sidebar","previous":{"title":"Inductive Types","permalink":"/docs/language/inductive-types"},"next":{"title":"Generics","permalink":"/docs/language/generics"}}');var i=n(4848),r=n(8453);const s={sidebar_position:9},o="Attributes",c={},d=[{value:"The attributes Statement",id:"the-attributes-statement",level:2},{value:"Operators",id:"operators",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"attributes",children:"Attributes"})}),"\n",(0,i.jsx)(t.p,{children:"Once you've defined an inductive type or a structure type, you can augment it with additional attributes."}),"\n",(0,i.jsxs)(t.p,{children:["For example, let's start with this ",(0,i.jsx)(t.code,{children:"LatticePoint"})," structure type."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-acorn",children:"from int import Int\nnumerals Int\n\nstructure LatticePoint {\n    x: Int\n    y: Int\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"the-attributes-statement",children:"The attributes Statement"}),"\n",(0,i.jsxs)(t.p,{children:["To add extra attributes to the ",(0,i.jsx)(t.code,{children:"LatticePoint"})," type, you can define both functions and variables inside a block with the ",(0,i.jsx)(t.code,{children:"attributes"})," keyword."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-acorn",children:"attributes LatticePoint {\n    // Now accessible as LatticePoint.origin\n    let origin = LatticePoint.new(0, 0)\n\n    // Now accessible as LatticePoint.swap\n    define swap(self) -> LatticePoint {\n        LatticePoint.new(self.y, self.x)\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The first argument to a function must be named ",(0,i.jsx)(t.code,{children:"self"}),", and it automatically get the type that we're defining attributes for."]}),"\n",(0,i.jsxs)(t.p,{children:["Constants and functions defined inside an ",(0,i.jsx)(t.code,{children:"attributes"})," block are now attributes accessible as ",(0,i.jsx)(t.code,{children:"TypeName.attribute_name"}),". For example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-acorn",children:"theorem swap_is_involutive(p: LatticePoint) {\n    p.swap.swap = p\n} by {\n    p.swap.x = p.y\n    p.swap.y = p.x\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The names for constants and functions inside an attributes block are the same as outside, except that constants in an\nattributes block can also have numeric names. Thus ",(0,i.jsx)(t.code,{children:"Nat.0"})," is the name for zero, the natural number, and ",(0,i.jsx)(t.code,{children:"Int.0"})," is the name for zero, the integer."]}),"\n",(0,i.jsxs)(t.p,{children:["Writing the ",(0,i.jsx)(t.code,{children:"numerals Int"})," statement lets us avoid typing ",(0,i.jsx)(t.code,{children:"Int."})," before every numeral."]}),"\n",(0,i.jsxs)(t.p,{children:["It's okay to have multiple ",(0,i.jsx)(t.code,{children:"attributes"})," blocks for a single type. You often want to define some attributes, prove some things about them, then define more attributes."]}),"\n",(0,i.jsx)(t.h2,{id:"operators",children:"Operators"}),"\n",(0,i.jsxs)(t.p,{children:["Every operator has a alphabetical reserved name. If you define a method of this name, the operator will work as well. For example, the ",(0,i.jsx)(t.code,{children:"+"})," operator corresponds to the name ",(0,i.jsx)(t.code,{children:"add"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-acorn",children:"attributes LatticePoint {\n    define add(self, other: LatticePoint) -> LatticePoint {\n        LatticePoint.new(self.x + other.x, self.y + other.y)\n    }\n}\n\ntheorem add_origin(p: LatticePoint) {\n    p + LatticePoint.origin = p\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"The names of the supported operators are:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-acorn",children:"// Greater than\na.gt(b) = a > b\n\n// Less than\na.lt(b) = a < b\n\n// Greater than or equal to\na.gte(b) = a >= b\n\n// Less than or equal to\na.lte(b) = a <= b\n\n// Addition\na.add(b) = a + b\n\n// Subtraction\na.sub(b) = a - b\n\n// Multiplication\na.mul(b) = a * b\n\n// Division\na.div(b) = a / b\n\n// Mod\na.mod(b) = a % b\n\n// Negative. The unary '-' is different from the binary '-'.\na.neg = -a\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);