"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[7454],{2238:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>l});var n=r(1616),o=r(4848),a=r(8453);const i={slug:"the-build-cache",title:"The Build Cache",authors:["lacker"],tags:["tooling"]},s=void 0,c={authorsImageUrls:[void 0]},l=[];function h(e){const t={code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"There's a useful new feature in Acorn Prover 0.0.8: a build cache."}),"\n",(0,o.jsxs)(t.p,{children:["When you save changes to an Acorn project, the AI model automatically completes simple proofs with missing steps. Usually this works great, but this can make refactoring more difficult. In particular, if you make changes to a module like ",(0,o.jsx)(t.code,{children:"nat.ac"})," that many other modules depend on, it can be slow to rebuild everything. If you want to remove a theorem that is used in many places, this can involve many slow rebuilds."]}),"\n",(0,o.jsxs)(t.p,{children:["The build cache mostly solves this problem. Instead of discarding the detailed proof after finding it, Acorn now saves build artifacts in a ",(0,o.jsx)(t.code,{children:"build"})," directory of the library. While testing, this speeds up partially-cached refactoring operations like renames by a factor of roughly 10x."]}),"\n",(0,o.jsx)(t.p,{children:"These build artifacts are somewhat human-readable, for the curious. In particular, it can be interesting to see the dependencies between theorems. These make up most of the build cache, as premise selection is the vast majority of the work of the prover:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"  add_from_int:\n    rat:\n    - add_int_eq_int_add\n    real:\n    - Real.from_int\n    - add_from_rat\n"})}),"\n",(0,o.jsx)(t.p,{children:"For the most part, though, you won't notice anything visibly different with Acorn 0.0.8. Everything should just be faster, and work the same way you're used to. Give it a try!"})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var n=r(6540);const o={},a=n.createContext(o);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(a.Provider,{value:t},e.children)}},1616:e=>{e.exports=JSON.parse('{"permalink":"/blog/the-build-cache","editUrl":"https://github.com/acornprover/acornprover.org/edit/master/blog/2025-03-13-the-build-cache.md","source":"@site/blog/2025-03-13-the-build-cache.md","title":"The Build Cache","description":"There\'s a useful new feature in Acorn Prover 0.0.8: a build cache.","date":"2025-03-13T00:00:00.000Z","tags":[{"inline":false,"label":"tooling","permalink":"/blog/tags/tooling","description":"Posts about the Acorn tools, like the VS Code extension."}],"hasTruncateMarker":true,"authors":[{"name":"Kevin Lacker","title":"Generalist","url":"https://lacker.io","page":{"permalink":"/blog/authors/lacker"},"socials":{"x":"https://x.com/lacker","github":"https://github.com/lacker"},"imageURL":"https://github.com/lacker.png","key":"lacker"}],"frontMatter":{"slug":"the-build-cache","title":"The Build Cache","authors":["lacker"],"tags":["tooling"]},"unlisted":false,"prevItem":{"title":"Typeclasses and Generic Inductive Types","permalink":"/blog/typeclasses-and-generic-inductive-types"},"nextItem":{"title":"Generics","permalink":"/blog/generics"}}')}}]);