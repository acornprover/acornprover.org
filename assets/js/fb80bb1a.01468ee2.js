"use strict";(self.webpackChunkacornprover_org=self.webpackChunkacornprover_org||[]).push([[8905],{4826:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"tutorial/induction","title":"Induction","description":"Induction is the soul of the natural numbers. You prove something is true for zero, and that whenever it\'s true for one number, it\'s true for the next one. And there you go, it\'s true for all natural numbers.","source":"@site/docs/tutorial/induction.md","sourceDirName":"tutorial","slug":"/tutorial/induction","permalink":"/docs/tutorial/induction","draft":false,"unlisted":false,"editUrl":"https://github.com/acornprover/acornprover.org/edit/master/docs/tutorial/induction.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"sidebar","previous":{"title":"Indirect Proofs","permalink":"/docs/tutorial/indirect-proofs"},"next":{"title":"The Acorn Master Plan","permalink":"/docs/tutorial/master-plan"}}');var r=t(4848),i=t(8453);const s={sidebar_position:4},a="Induction",h={},l=[{value:"Our Starting Point",id:"our-starting-point",level:2},{value:"Proof By Induction",id:"proof-by-induction",level:2},{value:"Method One: Lots Of Little Theorems",id:"method-one-lots-of-little-theorems",level:2},{value:"Method Two: One Big Theorem",id:"method-two-one-big-theorem",level:2},{value:"Philosophy",id:"philosophy",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"induction",children:"Induction"})}),"\n",(0,r.jsx)(n.p,{children:"Induction is the soul of the natural numbers. You prove something is true for zero, and that whenever it's true for one number, it's true for the next one. And there you go, it's true for all natural numbers."}),"\n",(0,r.jsx)(n.p,{children:"Let's try an example."}),"\n",(0,r.jsx)(n.h2,{id:"our-starting-point",children:"Our Starting Point"}),"\n",(0,r.jsxs)(n.p,{children:["If you've been going through the tutorial linearly, delete the stuff about ",(0,r.jsx)(n.code,{children:"throdd"}),", to keep this example focused. Start with the ",(0,r.jsxs)(n.a,{href:"https://github.com/acornprover/acornprover.org/blob/master/examples/threeven.ac",children:[(0,r.jsx)(n.code,{children:"threeven"})," code"]}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"from nat import Nat\nnumerals Nat\n\ndefine threeven(n: Nat) -> Bool {\n    exists(d: Nat) {\n        3 * d = n\n    }\n}\n\ntheorem zero_is_threeven {\n    threeven(0)\n}\n\ntheorem threeven_plus_three(n: Nat) {\n    threeven(n) -> threeven(n + 3)\n} by {\n    let d: Nat satisfy {\n        3 * d = n\n    }\n    3 * (d + 1) = n + 3\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"proof-by-induction",children:"Proof By Induction"}),"\n",(0,r.jsx)(n.p,{children:"Our goal is to prove that for any three consecutive numbers, one of them must be threeven."}),"\n",(0,r.jsx)(n.p,{children:"Let's write this theorem using a separate definition for our goal."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"define threeven_nearby(n: Nat) -> Bool {\n    threeven(n) or threeven(n + 1) or threeven(n + 2)\n}\n\ntheorem threeven_everywhere(n: Nat) {\n    threeven_nearby(n)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Type these in and save, and the theorem will get yellow-squiggled. It isn't simple enough to be proven in one step. (Unless you left in the theorem ",(0,r.jsx)(n.code,{children:"threeven_kinda_follows_throdd"})," from the previous tutorial section, for which this theorem is a trivial corollary. That's why we deleted the throdd stuff!)"]}),"\n",(0,r.jsx)(n.p,{children:"So, we have to do a proof by induction. Induction isn't an explicit theorem in Acorn, because it's part of the kernel, rather than part of the standard library. But if it were an explicit theorem, it would look something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"// This code does not actually compile, don't use it!\ntheorem Nat.induction(f: Nat -> Bool, n: Nat) {\n    f(0) and forall(k: Nat) { f(k) -> f(k + 1) } -> f(n)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's look at the parts of this code."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Nat -> Bool"})," is a type. It means functions that take a natural number, and return a boolean value."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"f(0)"})," is the base case, that ",(0,r.jsx)(n.code,{children:"f"})," is true for zero. You can think of ",(0,r.jsx)(n.code,{children:"f"})," as either a function, or a proposition. They work the same way in Acorn."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"forall(k: Nat) { f(k) -> f(k + 1) }"})," is the inductive step. When ",(0,r.jsx)(n.code,{children:"f"})," is true for ",(0,r.jsx)(n.code,{children:"k"}),", it must also be true for ",(0,r.jsx)(n.code,{children:"k + 1"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"method-one-lots-of-little-theorems",children:"Method One: Lots Of Little Theorems"}),"\n",(0,r.jsxs)(n.p,{children:["One way to do prove ",(0,r.jsx)(n.code,{children:"threeven_everywhere"})," is by making the base case and inductive step their own theorems. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"define threeven_nearby(n: Nat) -> Bool {\n    threeven(n) or threeven(n + 1) or threeven(n + 2)\n}\n\ntheorem base_case {\n    threeven_nearby(0)\n}\n\ntheorem inductive_step(n: Nat) {\n    threeven_nearby(n) -> threeven_nearby(n + 1)\n} by {\n    if threeven(n) {\n        threeven(n + 3)\n        threeven_nearby(n + 1)\n    } else {\n        threeven(n + 1) or threeven(n + 2)\n        threeven_nearby(n + 1)\n    }\n}\n\ntheorem threeven_everywhere(n: Nat) {\n    threeven_nearby(n)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:'We use a short proof by contradiction to prove the inductive step, and otherwise the steps are trivial. We don\'t need to explicitly cite "induction". We just need to prove the base case and the inductive step, and Acorn will do the lookup itself.'}),"\n",(0,r.jsx)(n.h2,{id:"method-two-one-big-theorem",children:"Method Two: One Big Theorem"}),"\n",(0,r.jsx)(n.p,{children:"Another way to do the same thing is by proving the base case and the inductive step inline, as steps in a multi-step proof. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"define threeven_nearby(n: Nat) -> Bool {\n    threeven(n) or threeven(n + 1) or threeven(n + 2)\n}\n\ntheorem threeven_everywhere(n: Nat) {\n    threeven_nearby(n)\n} by {\n    // Base case\n    threeven_nearby(0)\n\n    // Inductive step\n    forall(m: Nat) {\n        if threeven_nearby(m) {\n            if threeven(m) {\n                threeven(m + 3)\n                threeven_nearby(m + 1)\n            } else {\n                threeven(m + 1) or threeven(m + 2)\n                threeven_nearby(m + 1)\n            }\n\n            // Not necessary, but here for clarity\n            threeven_nearby(m + 1)\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is essentially the same logic as the first example, just written as a single function. The ",(0,r.jsx)(n.code,{children:"forall"})," statement works like it's an anonymous, inline theorem. The last line of an ",(0,r.jsx)(n.code,{children:"if"})," statement works like it's the conclusion of a theorem. So in this code:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-acorn",children:"// Named theorem version\ntheorem my_theorem(x: MyType) {\n    foo(x) -> bar(x)\n} by {\n    first_step\n    second_step\n}\n\n// Same thing, but anonymous\nforall(x: MyType) {\n    if foo(x) {\n        first_step\n        second_step\n        bar(x)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The two examples are proving the same theorem."}),"\n",(0,r.jsx)(n.h2,{id:"philosophy",children:"Philosophy"}),"\n",(0,r.jsx)(n.p,{children:"For the most part, a proof by induction works the same way as any other Acorn proof. You go step by step, and induction is just the last step. There's no special syntax for it."}),"\n",(0,r.jsxs)(n.p,{children:["In Acorn, you don't have to express ",(0,r.jsx)(n.em,{children:"why"})," each line is true. You only have to express ",(0,r.jsx)(n.em,{children:"what"})," is true."]}),"\n",(0,r.jsx)(n.p,{children:'Many theorem provers are based on a concept of "tactics", that let you precisely explain why a theorem is true. Acorn is designed to fill in the tactics using AI when it verifies code, to make it easier for people to formalize proofs.'}),"\n",(0,r.jsx)(n.p,{children:"Does this actually work? Yes. Sure. Well, it mostly works. And it'll get better and better as AI gets better. Eventually, you should be able to only jot down the key points of a proof, the way you would communicate a proof to a smart human mathematician, and have the AI fill in the blanks."}),"\n",(0,r.jsx)(n.p,{children:"Try it for yourself!"})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(6540);const r={},i=o.createContext(r);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);